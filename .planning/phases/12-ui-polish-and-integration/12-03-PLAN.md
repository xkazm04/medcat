---
phase: 12-ui-polish-and-integration
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/components/table/columns.tsx
  - src/components/table/data-table.tsx
  - src/components/chat/chat-widget.tsx
  - src/components/catalog-client.tsx
  - src/lib/hooks/use-chat-context.tsx
autonomous: true

must_haves:
  truths:
    - "User can click product name in table to insert it into chat input"
    - "User can click vendor name in table to insert it into chat input"
    - "User can click category name in table to insert it into chat input"
    - "Chat opens automatically when table value is clicked"
    - "Clickable cells have visual hover indicator (cursor, highlight)"
    - "Row-level 'Ask AI' button sends complete query to chat"
  artifacts:
    - path: "src/lib/hooks/use-chat-context.tsx"
      provides: "React context for chat input insertion from anywhere"
      min_lines: 30
    - path: "src/components/table/columns.tsx"
      contains: "ChatInsertCell"
  key_links:
    - from: "src/components/table/columns.tsx"
      to: "src/lib/hooks/use-chat-context.tsx"
      via: "useChatContext hook"
      pattern: "useChatContext"
    - from: "src/components/catalog-client.tsx"
      to: "ChatContextProvider"
      via: "wraps table and chat"
      pattern: "ChatContextProvider"
---

<objective>
Connect catalog table with chat for seamless UX - click any value (product name, vendor, category) to insert into chat and ask questions.

Purpose: Procurement users browse the catalog table and need to quickly ask the AI about specific products, vendors, or categories without manual typing.

Output: Clickable table cells that insert values into chat input, with visual feedback and automatic chat opening.
</objective>

<context>
@.planning/phases/12-ui-polish-and-integration/12-CONTEXT.md
@src/components/table/columns.tsx
@src/components/table/data-table.tsx
@src/components/chat/chat-widget.tsx
@src/components/catalog-client.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatContext for cross-component communication</name>
  <files>src/lib/hooks/use-chat-context.tsx</files>
  <action>
Create a React Context that allows any component to insert text into the chat input.

```typescript
'use client';

import { createContext, useContext, useState, useCallback, ReactNode } from 'react';

interface ChatContextValue {
  // Insert text into chat input (appends if input has content)
  insertText: (text: string) => void;
  // Open chat panel if closed
  openChat: () => void;
  // Combined: open chat and insert text
  askAbout: (text: string) => void;
  // Send a complete message directly
  sendMessage: (text: string) => void;
  // Register the chat input setter (called by ChatInput)
  registerInputSetter: (setter: (text: string) => void) => void;
  // Register the chat open function (called by ChatWidget)
  registerOpenChat: (opener: () => void) => void;
  // Register send message function (called by ChatPanel)
  registerSendMessage: (sender: (text: string) => void) => void;
}

const ChatContext = createContext<ChatContextValue | null>(null);

export function ChatContextProvider({ children }: { children: ReactNode }) {
  const [inputSetter, setInputSetter] = useState<((text: string) => void) | null>(null);
  const [chatOpener, setChatOpener] = useState<(() => void) | null>(null);
  const [messageSender, setMessageSender] = useState<((text: string) => void) | null>(null);

  const registerInputSetter = useCallback((setter: (text: string) => void) => {
    setInputSetter(() => setter);
  }, []);

  const registerOpenChat = useCallback((opener: () => void) => {
    setChatOpener(() => opener);
  }, []);

  const registerSendMessage = useCallback((sender: (text: string) => void) => {
    setMessageSender(() => sender);
  }, []);

  const insertText = useCallback((text: string) => {
    if (inputSetter) {
      inputSetter(text);
    }
  }, [inputSetter]);

  const openChat = useCallback(() => {
    if (chatOpener) {
      chatOpener();
    }
  }, [chatOpener]);

  const askAbout = useCallback((text: string) => {
    openChat();
    // Small delay to ensure chat is open before inserting
    setTimeout(() => insertText(text), 50);
  }, [openChat, insertText]);

  const sendMessage = useCallback((text: string) => {
    openChat();
    setTimeout(() => {
      if (messageSender) {
        messageSender(text);
      }
    }, 50);
  }, [openChat, messageSender]);

  return (
    <ChatContext.Provider value={{
      insertText,
      openChat,
      askAbout,
      sendMessage,
      registerInputSetter,
      registerOpenChat,
      registerSendMessage,
    }}>
      {children}
    </ChatContext.Provider>
  );
}

export function useChatContext() {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChatContext must be used within ChatContextProvider');
  }
  return context;
}

// Optional hook that doesn't throw - for components that might be outside provider
export function useChatContextOptional() {
  return useContext(ChatContext);
}
```
  </action>
  <verify>
File exists and exports ChatContextProvider, useChatContext
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
ChatContext created with insertText, openChat, askAbout, sendMessage functions and registration callbacks
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ChatContext into ChatWidget and ChatInput</name>
  <files>
    src/components/chat/chat-widget.tsx
    src/components/chat/chat-input.tsx
    src/components/chat/chat-panel.tsx
  </files>
  <action>
1. Update `chat-widget.tsx`:
   - Import useChatContext
   - Register openChat callback: `chatContext.registerOpenChat(() => setIsOpen(true))`
   - Use useEffect to register on mount

2. Update `chat-input.tsx`:
   - Add controlled input value state (if not already)
   - Import useChatContextOptional (optional to not break if used outside provider)
   - Register input setter: `chatContext?.registerInputSetter((text) => setInputValue(prev => prev ? `${prev} ${text}` : text))`
   - The setter appends text with space if input already has content

3. Update `chat-panel.tsx`:
   - Import useChatContextOptional
   - Register sendMessage callback that calls the existing handleSubmit
   - `chatContext?.registerSendMessage((text) => handleSubmit(text))`
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
ChatWidget registers openChat, ChatInput registers text setter, ChatPanel registers sendMessage
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ChatInsertCell component for clickable table values</name>
  <files>src/components/table/chat-insert-cell.tsx</files>
  <action>
Create a reusable cell component that inserts its value into chat on click.

```typescript
'use client';

import { useChatContextOptional } from '@/lib/hooks/use-chat-context';
import { cn } from '@/lib/utils';

interface ChatInsertCellProps {
  value: string;
  prefix?: string; // e.g., "Show me products from vendor: "
  className?: string;
}

export function ChatInsertCell({ value, prefix = '', className }: ChatInsertCellProps) {
  const chatContext = useChatContextOptional();

  if (!chatContext || !value) {
    // Fallback: just render the value without interactivity
    return <span className={className}>{value}</span>;
  }

  const handleClick = () => {
    const textToInsert = prefix ? `${prefix}${value}` : value;
    chatContext.askAbout(textToInsert);
  };

  return (
    <button
      type="button"
      onClick={handleClick}
      className={cn(
        'text-left hover:text-primary hover:underline cursor-pointer',
        'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-1 rounded',
        'transition-colors',
        className
      )}
      title={`Click to ask about "${value}"`}
    >
      {value}
    </button>
  );
}
```
  </action>
  <verify>
File exists
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
ChatInsertCell component created - renders clickable button that inserts value into chat
  </done>
</task>

<task type="auto">
  <name>Task 4: Create AskAIButton for row-level quick action</name>
  <files>src/components/table/ask-ai-button.tsx</files>
  <action>
Create a button that sends a complete question about a product to chat.

```typescript
'use client';

import { MessageCircle } from 'lucide-react';
import { useChatContextOptional } from '@/lib/hooks/use-chat-context';
import { cn } from '@/lib/utils';

interface AskAIButtonProps {
  productName: string;
  className?: string;
}

export function AskAIButton({ productName, className }: AskAIButtonProps) {
  const chatContext = useChatContextOptional();

  if (!chatContext) {
    return null; // Don't render if outside provider
  }

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Don't trigger row selection
    chatContext.sendMessage(`Tell me about ${productName}`);
  };

  return (
    <button
      type="button"
      onClick={handleClick}
      className={cn(
        'p-1.5 rounded-md hover:bg-muted transition-colors',
        'text-muted-foreground hover:text-primary',
        'focus:outline-none focus:ring-2 focus:ring-ring',
        className
      )}
      title={`Ask AI about ${productName}`}
    >
      <MessageCircle className="h-4 w-4" />
    </button>
  );
}
```
  </action>
  <verify>
File exists
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
AskAIButton component created - sends "Tell me about [product]" to chat on click
  </done>
</task>

<task type="auto">
  <name>Task 5: Update table columns to use ChatInsertCell and AskAIButton</name>
  <files>src/components/table/columns.tsx</files>
  <action>
Update the column definitions to use the new interactive components.

1. Import ChatInsertCell and AskAIButton
2. Update the "name" column cell to use ChatInsertCell
3. Update the "vendor" column cell to use ChatInsertCell with prefix "Show me products from "
4. Update the "category" column cell to use ChatInsertCell with prefix "Show me products in category "
5. Add an "actions" column (or update existing) with AskAIButton

Example for name column:
```typescript
{
  accessorKey: 'name',
  header: ({ column }) => <SortableHeader column={column} title="Name" />,
  cell: ({ row }) => (
    <ChatInsertCell
      value={row.original.name}
      className="font-medium"
    />
  ),
}
```

Example for vendor column:
```typescript
{
  accessorKey: 'vendor',
  header: 'Vendor',
  cell: ({ row }) => (
    <ChatInsertCell
      value={row.original.vendor?.name || ''}
      prefix="Show me products from "
    />
  ),
}
```

Add actions column at the end:
```typescript
{
  id: 'ask-ai',
  header: '',
  cell: ({ row }) => (
    <AskAIButton productName={row.original.name} />
  ),
  size: 50,
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
grep for ChatInsertCell in columns.tsx
grep for AskAIButton in columns.tsx
  </verify>
  <done>
Table columns updated: name/vendor/category cells are clickable, AskAI button added to each row
  </done>
</task>

<task type="auto">
  <name>Task 6: Wrap catalog page with ChatContextProvider</name>
  <files>src/components/catalog-client.tsx</files>
  <action>
Wrap the CatalogClient component content with ChatContextProvider so both the table and chat can access the context.

1. Import ChatContextProvider from '@/lib/hooks/use-chat-context'
2. Wrap the entire return JSX with ChatContextProvider:

```typescript
return (
  <ChatContextProvider>
    <div className="flex h-[calc(100vh-4rem)]">
      {/* existing content */}
    </div>
  </ChatContextProvider>
);
```

This ensures both DataTable and ChatWidget share the same context.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
grep for ChatContextProvider in catalog-client.tsx
  </verify>
  <done>
CatalogClient wrapped with ChatContextProvider - table and chat can now communicate
  </done>
</task>

<task type="auto">
  <name>Task 7: Visual polish and testing</name>
  <files>N/A - verification only</files>
  <action>
1. Start dev server: `npm run dev`
2. Open http://localhost:3000

Test scenarios:
1. Hover over product name → should show pointer cursor and underline hint
2. Click product name → chat opens, product name inserted into input
3. Click vendor name → chat opens, "Show me products from [vendor]" inserted
4. Click category name → chat opens, "Show me products in category [category]" inserted
5. Click AskAI button (chat icon) → chat opens and sends "Tell me about [product]"
6. If input already has text, new text appends with space

Verify visual feedback:
- Clickable cells have hover effect
- AskAI button has hover state
- Chat input receives focus after insertion
  </action>
  <verify>
Dev server runs without errors
All click interactions work as expected
Visual hover states are present
  </verify>
  <done>
Table-chat integration complete: clickable cells insert values, AskAI button sends queries, visual feedback present
  </done>
</task>

</tasks>

<verification>
All checks:
- [ ] ChatContext created with insertText, openChat, askAbout, sendMessage
- [ ] ChatWidget registers openChat callback
- [ ] ChatInput registers text setter callback
- [ ] ChatPanel registers sendMessage callback
- [ ] ChatInsertCell component renders clickable values
- [ ] AskAIButton component sends queries to chat
- [ ] Table columns use ChatInsertCell for name/vendor/category
- [ ] Table has AskAI button column
- [ ] CatalogClient wrapped with ChatContextProvider
- [ ] TypeScript compiles without errors
- [ ] Visual hover states on clickable cells
- [ ] Chat opens when table value clicked
</verification>

<success_criteria>
1. User can click product name → opens chat with name in input
2. User can click vendor name → opens chat with "Show me products from [vendor]"
3. User can click category → opens chat with "Show me products in category [category]"
4. User can click AskAI button → sends complete question to chat
5. Visual hover indicators show which cells are clickable
6. If chat input has text, new text appends (doesn't replace)
</success_criteria>

<output>
After completion, create `.planning/phases/12-ui-polish-and-integration/12-03-SUMMARY.md`
</output>
