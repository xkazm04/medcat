---
phase: 09-catalog-search-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/chat/tools.ts
  - src/app/api/chat/route.ts
  - src/lib/chat/constants.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "AI receives tool definitions when processing chat messages"
    - "AI can execute searchProducts tool and return product data"
    - "AI can execute comparePrices tool and return vendor pricing"
    - "AI can execute suggestCategories tool and return EMDN suggestions"
    - "User can ask to compare prices for a search result and AI executes both tools in sequence"
  artifacts:
    - path: "src/lib/chat/tools.ts"
      provides: "Three tool definitions with Zod schemas"
      exports: ["searchProducts", "comparePrices", "suggestCategories"]
    - path: "src/app/api/chat/route.ts"
      provides: "Chat endpoint with tool calling"
      contains: "tools:"
    - path: "src/lib/chat/constants.ts"
      provides: "Tool-aware system prompt"
      contains: "searchProducts tool"
  key_links:
    - from: "src/app/api/chat/route.ts"
      to: "src/lib/chat/tools.ts"
      via: "import { searchProducts, comparePrices, suggestCategories }"
      pattern: "import.*tools"
    - from: "src/lib/chat/tools.ts"
      to: "src/lib/queries.ts"
      via: "getProducts() call in searchProducts.execute"
      pattern: "getProducts\\("
    - from: "src/lib/chat/tools.ts"
      to: "src/lib/actions/similarity.ts"
      via: "getProductPriceComparison() call in comparePrices.execute"
      pattern: "getProductPriceComparison\\("
---

<objective>
Create AI tool definitions for catalog search, price comparison, and category suggestions.

Purpose: Enable the AI to query the product database via structured tools, translating natural language queries into database operations using existing query functions.

Output: Three working tools (searchProducts, comparePrices, suggestCategories) integrated into the chat API route with multi-step execution support.
</objective>

<execution_context>
@C:\Users\mkdol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mkdol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-catalog-search-tools/09-RESEARCH.md
@.planning/phases/09-catalog-search-tools/09-CONTEXT.md
@src/app/api/chat/route.ts
@src/lib/chat/constants.ts
@src/lib/queries.ts
@src/lib/actions/similarity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool definitions</name>
  <files>src/lib/chat/tools.ts</files>
  <action>
Create `src/lib/chat/tools.ts` with three tool definitions using Vercel AI SDK `tool` function:

**searchProducts tool:**
- Import `tool` from 'ai' and `z` from 'zod'
- Import `getProducts` from '@/lib/queries'
- InputSchema: query (string, required), category (string, optional), vendor (string, optional), material (string, optional), minPrice (number, optional), maxPrice (number, optional), limit (number, default 5)
- Use `.describe()` on EVERY Zod field to help LLM understand parameter purposes
- Execute: call getProducts() mapping parameters to its interface
- Return: { products, totalCount, showing }

**comparePrices tool:**
- Import `getProductPriceComparison` from '@/lib/actions/similarity'
- InputSchema: productId (string UUID)
- Execute: call getProductPriceComparison(productId)
- Map return value: getProductPriceComparison returns `{ success, data, error }` format
  - If `result.success` is true: return `{ products: result.data || [], count: result.data?.length || 0 }`
  - If `result.success` is false: return `{ error: result.error, products: [] }`
- This mapping ensures consistent return type for the UI layer

**suggestCategories tool:**
- InputSchema: query (string)
- Execute: call getProducts with query, pageSize 50
- Aggregate categories from results:
  1. Create a Map keyed by `emdn_category.id` to accumulate counts
  2. For each product in results:
     - If `product.emdn_category` is null, skip (do not show "Uncategorized")
     - Otherwise increment count for that category id
  3. Convert Map to array of `{ id, code, name, count }` objects
  4. Sort by count descending
  5. Return top 5
- Return: { suggestions: Array<{id, code, name, count}>, totalProducts }

Export all three tools as named exports.

Reference RESEARCH.md Pattern 1 for exact code structure.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/chat/tools.ts`
All three tools exported: `grep -E "export const (searchProducts|comparePrices|suggestCategories)" src/lib/chat/tools.ts`
  </verify>
  <done>
Three tool definitions exist with Zod schemas, descriptions, and execute functions that wrap existing query functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate tools into chat API and update system prompt</name>
  <files>src/app/api/chat/route.ts, src/lib/chat/constants.ts</files>
  <action>
**Update src/app/api/chat/route.ts:**
- Import `stepCountIs` from 'ai'
- Import tools: `import { searchProducts, comparePrices, suggestCategories } from '@/lib/chat/tools'`
- Add `tools` object to streamText call with all three tools
- Add `stopWhen: stepCountIs(3)` for multi-step execution (search -> compare -> synthesize)
- Keep existing abortSignal: req.signal

**Update src/lib/chat/constants.ts:**
Replace SYSTEM_PROMPT with tool-aware version from RESEARCH.md:
- List capabilities: searchProducts, comparePrices, suggestCategories
- Add guidelines for when to use each tool:
  - "find/show/search products" -> searchProducts
  - "compare prices" -> comparePrices
  - "broad/ambiguous queries" -> suggestCategories
- Add formatting guidance: "Showing X of Y results"
- Add limitations: read-only, catalog only (no web search yet)

Reference RESEARCH.md Pattern 2 and "Updated System Prompt" code example.
  </action>
  <verify>
Build succeeds: `npm run build`
Tools imported in route: `grep "tools" src/app/api/chat/route.ts`
System prompt mentions tools: `grep "searchProducts" src/lib/chat/constants.ts`
  </verify>
  <done>
Chat API includes tool definitions, multi-step execution enabled, system prompt instructs AI when to use each tool.
  </done>
</task>

</tasks>

<verification>
Run full build: `npm run build`
Start dev server: `npm run dev`
Manual test via chat widget:
1. Open chat, type "find titanium implants"
2. Observe network request to /api/chat includes tool execution
3. Response includes tool call in message parts (visible in browser devtools)

Note: Visual rendering of tool results is Plan 02 - this plan verifies tools execute and return data.
</verification>

<success_criteria>
- Three tools defined in src/lib/chat/tools.ts with proper Zod schemas
- Chat API route imports and passes tools to streamText
- Multi-step execution enabled (stopWhen: stepCountIs(3))
- System prompt updated with tool usage guidance
- Build passes without TypeScript errors
- Tool calls appear in chat API response stream when user asks product questions
</success_criteria>

<output>
After completion, create `.planning/phases/09-catalog-search-tools/09-01-SUMMARY.md`
</output>
