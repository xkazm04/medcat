---
phase: 02-product-management
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - src/components/product/product-sheet.tsx
  - src/components/table/columns.tsx
  - src/app/page.tsx
autonomous: false

must_haves:
  truths:
    - "Clicking 'View details' opens product sheet"
    - "User can switch between view and edit modes"
    - "User can delete product from sheet"
    - "Changes reflect in table after save/delete"
  artifacts:
    - path: "src/components/product/product-sheet.tsx"
      provides: "Product sheet orchestrator"
      exports: ["ProductSheet"]
  key_links:
    - from: "src/components/table/columns.tsx"
      to: "src/components/product/product-sheet.tsx"
      via: "onViewProduct callback"
      pattern: "onViewProduct"
    - from: "src/app/page.tsx"
      to: "src/components/product/product-sheet.tsx"
      via: "ProductSheet render"
      pattern: "<ProductSheet"
---

<objective>
Integrate all product components into a working product sheet and wire to the table row actions.

Purpose: Complete the product management flow - view, edit, delete from table row actions
Output: Fully functional product management with sheet UI
</objective>

<execution_context>
@C:\Users\kazda\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kazda\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-product-management/02-RESEARCH.md
@src/app/page.tsx
@src/components/table/columns.tsx
@src/components/table/data-table.tsx
@src/components/product/product-detail.tsx
@src/components/product/product-form.tsx
@src/components/product/delete-dialog.tsx
@src/components/ui/sheet.tsx
@src/lib/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProductSheet orchestrator</name>
  <files>src/components/product/product-sheet.tsx</files>
  <action>
Create src/components/product/product-sheet.tsx - orchestrates view/edit/delete modes:

1. Mark 'use client'

2. Import:
   - Sheet components from @/components/ui/sheet
   - ProductDetail from ./product-detail
   - ProductForm from ./product-form
   - DeleteDialog from ./delete-dialog
   - ProductWithRelations, Vendor, Material, EMDNCategory from @/lib/types
   - useState from react
   - Pencil, Trash2, Eye from lucide-react

3. Props interface (ProductSheetProps):
   - product: ProductWithRelations | null
   - open: boolean
   - onOpenChange: (open: boolean) => void
   - vendors: Vendor[]
   - materials: Material[]
   - emdnCategories: EMDNCategory[]

4. Component state:
   - mode: 'view' | 'edit' (default 'view')
   - deleteDialogOpen: boolean (default false)

5. Reset mode to 'view' when sheet opens (useEffect on open prop)

6. Sheet structure:
   - Sheet (open, onOpenChange)
   - SheetContent (side="right")
   - SheetHeader:
     - SheetTitle: product?.name || 'Product'
     - Action buttons row (flex gap-2):
       - View button (if mode === 'edit'): Eye icon, onClick -> setMode('view')
       - Edit button (if mode === 'view'): Pencil icon, onClick -> setMode('edit')
       - Delete button: Trash2 icon (text-red-600), onClick -> setDeleteDialogOpen(true)

7. Content area (below header):
   - If no product: "No product selected"
   - If mode === 'view': <ProductDetail product={product} />
   - If mode === 'edit':
     <ProductForm
       product={product}
       vendors={vendors.map(v => ({ id: v.id, name: v.name }))}
       materials={materials.map(m => ({ id: m.id, name: m.name }))}
       emdnCategories={emdnCategories.map(c => ({ id: c.id, code: c.code, name: c.name }))}
       onSuccess={() => {
         setMode('view')
         // Sheet stays open, data revalidates automatically
       }}
     />

8. DeleteDialog (outside Sheet content):
   - productId={product?.id || ''}
   - productName={product?.name || ''}
   - open={deleteDialogOpen}
   - onOpenChange={setDeleteDialogOpen}
   - onDeleted={() => {
       onOpenChange(false) // Close sheet after delete
     }}

9. Export ProductSheet
  </action>
  <verify>
    - npx tsc --noEmit (no type errors)
    - grep "ProductDetail" src/components/product/product-sheet.tsx
    - grep "ProductForm" src/components/product/product-sheet.tsx
    - grep "DeleteDialog" src/components/product/product-sheet.tsx
  </verify>
  <done>ProductSheet orchestrates view/edit/delete with mode switching and delete confirmation</done>
</task>

<task type="auto">
  <name>Task 2: Wire ProductSheet to table and page</name>
  <files>src/components/table/columns.tsx, src/app/page.tsx</files>
  <action>
1. Update src/components/table/columns.tsx:

   Change columns from static export to factory function:
   ```typescript
   export function createColumns(
     onViewProduct: (product: ProductWithRelations) => void,
     onEditProduct: (product: ProductWithRelations) => void,
     onDeleteProduct: (product: ProductWithRelations) => void
   ): ColumnDef<ProductWithRelations>[]
   ```

   Update actions cell:
   - "View details" onClick -> onViewProduct(row.original)
   - "Edit" onClick -> onEditProduct(row.original)
   - "Delete" (text-red-600) onClick -> onDeleteProduct(row.original)
   - Remove 'disabled' from all menu items

2. Update data-table.tsx:
   - Change props to accept columns (not import static)
   - Pass columns prop to useReactTable

3. Update src/app/page.tsx:

   Add to Server Component data fetching:
   - Fetch vendors: getVendors() (add to queries.ts if needed)
   - Fetch materials: getMaterials() (add to queries.ts if needed)
   - Fetch EMDN categories: getEMDNCategories() (add to queries.ts if needed)

   Pass data to a new Client Component wrapper (or lift state up):

   Create pattern:
   - page.tsx (Server) fetches all data
   - CatalogClient.tsx (Client) manages sheet state and renders table + sheet

   In CatalogClient:
   ```typescript
   const [selectedProduct, setSelectedProduct] = useState<ProductWithRelations | null>(null)
   const [sheetOpen, setSheetOpen] = useState(false)
   const [sheetMode, setSheetMode] = useState<'view' | 'edit'>('view')

   const columns = createColumns(
     (product) => { setSelectedProduct(product); setSheetMode('view'); setSheetOpen(true) },
     (product) => { setSelectedProduct(product); setSheetMode('edit'); setSheetOpen(true) },
     (product) => { setSelectedProduct(product); setSheetMode('view'); setSheetOpen(true); /* trigger delete from sheet */ }
   )
   ```

   Render:
   - DataTable with columns and data
   - ProductSheet with selectedProduct, open state, reference data

   Alternative simpler approach:
   - Keep sheet mode in ProductSheet component
   - Pass only onView/onEdit/onDelete callbacks
   - onView/onEdit both open sheet with product, mode set internally
   - onDelete opens sheet with delete dialog immediately
  </action>
  <verify>
    - npx tsc --noEmit (no type errors)
    - grep "createColumns" src/components/table/columns.tsx
    - grep "ProductSheet" src/app/page.tsx
    - Dev server runs: npm run dev (check for errors)
  </verify>
  <done>Table row actions open ProductSheet, view/edit/delete functional end-to-end</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify product management features</name>
  <what-built>
    Complete product management flow:
    - Product detail sheet with view mode
    - EMDN breadcrumb showing category hierarchy
    - Regulatory info display (UDI, CE marking, MDR class)
    - Edit form with all fields
    - Delete confirmation dialog
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Open http://localhost:3000

    TEST VIEW:
    3. Click the three-dot menu on any product row
    4. Click "View details"
    5. Verify sheet slides in from right with smooth animation
    6. Check product info is displayed correctly
    7. Check EMDN breadcrumb shows category path (if assigned)
    8. Check regulatory section shows UDI/CE/MDR fields

    TEST EDIT:
    9. Click the Edit (pencil) button in sheet header
    10. Verify form shows with pre-filled values
    11. Try editing a field (e.g., name)
    12. Click "Save Changes"
    13. Verify sheet shows updated data in view mode
    14. Verify table row reflects the change

    TEST DELETE:
    15. Click the Delete (trash) button in sheet header
    16. Verify confirmation dialog appears
    17. Click "Cancel" - dialog should close
    18. Click Delete again, then confirm
    19. Verify product removed from table
    20. Verify sheet closes after deletion

    TEST VALIDATION:
    21. Edit a product, clear the Name field
    22. Try to save - should show validation error
    23. Fix the name, save should work

    Note: If database not connected, edit/delete will fail - that's expected.
    The UI flow should still be testable with mock data display.
  </how-to-verify>
  <resume-signal>Type "approved" if all features work, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server runs without errors
3. Sheet opens from table row actions
4. View mode displays all product info
5. Edit mode shows form with validation
6. Delete shows confirmation and removes product
7. Table updates after mutations (revalidatePath works)
</verification>

<success_criteria>
Phase 2 Success Criteria (from ROADMAP.md):
1. User can view full product detail in modal or side panel - VERIFIED
2. User can see EMDN classification with hierarchy explanation - VERIFIED
3. User can edit product metadata and save changes - VERIFIED
4. User can delete products from the catalog - VERIFIED
5. User can see regulatory info (UDI, CE marking, MDR class) - VERIFIED
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-management/02-04-SUMMARY.md`
</output>
